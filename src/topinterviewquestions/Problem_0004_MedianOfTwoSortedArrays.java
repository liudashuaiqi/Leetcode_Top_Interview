package topinterviewquestions;
//int g(arr1有序,arr2有序,k)  arr1和arr2如果整体排完序之后，位于第k个数字是谁,k从1开始,也就是最小的第k个数是谁。
//arr1和arr2一共七个数字，最小的第4个就是答案
//arr1和arr2一共八个数字，调两次这个函数,最小的第4个数和最小的第5个数得到，两个数字相加除以2
//此函数也可以用在别的题目上

//等长有序数组求上中位数
//int f(arr1,arr2)//arr1&&arr2有序且长度相等,返回这两个东西整体排完序之后的上中位数
//arr1和arr2长度相等，所以一共是偶数个数字，返回上中位数
//arr1:1 4 arr2:2 3 返回2
//int f(arr1,L1,R1,arr2,L2,R2) arr1在L1....R1有序且arr2在L2...R2有序,且R1-L1==R2-L2
//(1) arr1[1,2,3,4]为偶数个数字,arr2[1^,2^,3^,4^]为偶数个数字. 代表在范围上的第几个这个含义
//  1,2,3,4 1^,2^,3^,4^ 混在一起排个序之后,第四小的数字是谁?拿两个数组的上中点对比一下 [2] PK [2^]
//  如果[2] == [2^] 返回 2位置所在的值就是整体的上中位数，为什么？ 因为一定有这样的关系(1,1^) 2,2^ (3,3^,4,4^) 括号内的数字顺序不知道,但是整体的顺序是这样.
//  如果[2] > [2^] arr1:那么对于3来说，1 2 位置的数在自己左边 1^ 2^ 也压在自己左边，所以3一定不是上中位数字,即永远不可能是第4小的,同理4也一定不是
//           arr2: 对于2^位置的数字来说,干的过1^,可能干的过1,但是肯定干不过2,所以2^最多就是第三小的数,所以2^一定不是上中位数,那么1^就更不可能了
//      对于剩下的1 2, 3^,4^都可能成为上中位数:
//          如果[2]<=[3^], 2 压过了1，又压过了1^,2^ 所以2就是第四小的数
//          如果[3^]<=[1]<=[4^],所以1位置搞定了1^2^3^, 但是搞不定234,如果1干过3^没干过4^,那1就是第4小的数字
//          总结：1 2 都有可能 ,底下3^ 4^也有可能
//          如果[1]<=[3^]<=[2],3^干过了1^2^1,没干过2,3^为第四小
//          如果[4^]<=[1],4^只干过了1^2^3^,没干过1,4^为第四小
//      综上所述,划定了不可能的范围,剩下的都是可能的
//      arr1中可能为1,2,arr2中可能为3^,4^
//      f函数说两段要等长, arr1剩下的范围和arr2剩下的范围等长，所以递归调用原始函数f
//      1,2,3^,4^这四个数中的上中位数,也就是第二小如果我求出来了，他就是原数组中的第4小,也就是接下来求 1,2,3^,4^这四个数中的上中位数就是最后整体的上中位数
//      证明：举个例子来说明。1,2,3^,4^这四个数中谁成为了我的上中位数
//      1) 1成为上中位数，1干过了3^ ,但没干过4^,1就成为了这四个数当中的上中位数，把这种情况套回原数组，就说明1就是整体的上中位数
//      2) 2成为上中位数，2没干过3^,肯定没干过4^,只欺负了1，把这种情况套回原数组,也就是说2是整体第四小
//      。。。。。。。 这四个数当中，不管是谁出来，谁成为了第二小，都是原数组的第四小
//  如果[2] < [2^] 情况反过来即可 3,4,1^,2^ 在找上中位数
//(2) arr1[1,2,3,4,5]为奇数个数字,arr2[1^,2^,3^,4^,5^]为奇数个数字.
//  还是找到中点,
//  如果[3]==[3^],直接返回3或3^的值，一定是上中位数,这一点跟偶数是一样的
//  如果[3]>[3^],谁是不可能的？这是十个数字求第五小,3已经把3^压在左边了,在自己的组里面干过了1,2,在人家的组里面干过了1^2^3^，干过了五个数字，3最好为第6小，3不可能，4,5就一定都不可能了
//      所以在arr1中3,4,5都是不可能的
//      3^是有可能的,只要干过2就行,这样就干过了1,2,在自己的数组中又干过了自己的小弟1^2^,他就是第五小,所以3^是有可能的
//      2^就没可能了,why？2^在自己的组里面只干过了1^,自己的大哥3^没干过人家的3,所以最好情况就是2^在上面的组里面干过了1,2，最多就是第4小，到不了第5小
//      所以在arr2中1^2^是不可能的
//  这样一来就有问题了,f函数想递归调用，必须两段等长,那么1,2跟3^4^5^无法去递归,因为不等长
//  怎么办？ 手动验证一下3^是不是第五小,看[3^]>=[2]? 前提已经是3^干不过3了,[3^]<[3],如果判断[3^]>=[2],直接返回[3^],就没有后序了,
//  但如果你发现不是这样,就手动的多淘汰了一个3^,这样的话1,2跟4^5^去求递归,就等长了,而且可以证明1,2跟4^5^的第二小对应回原数组就是第5小
//时间复杂度:arr1长度为N arr2长度为N 每次都是共同砍一半log(N)


//为了做出g函数，把f函数搞定
//为了实现原问题，把这两个函数都给大家讲了,这就是最优解，最后说最优解的指标有多优秀

//int g(arr1,arr2)arr1,arr2 有序不等长，返回整体排完序之后的第k小的数
//arr1:10个数字
//arr2:17个数字
//一共27个数字,求整体的第k小
//1) 1<=k<=10(10为短数组的长度), 比如k=7,怎么求？arr1中拿前7个,arr2中拿出前7个,这两段等长区域,调用f函数求整体的上中位数,搞定了
//2) (短数组长度)10<k<=17(长数组长度) 比如k=15,求第15小 怎么算？
//      arr1: 1 2 3 4 5 6 7 8 9 10
//      arr2: 1^2^3^4^,5,^6^7^8^9^10^11^12^13^14^15^,16^17^    ','表示下面要分的情况
//      arr1中所有的数字都有可能,如果1干过了14^,没干过15^,1就是整体的第15小,如果10干过了5^没有干过6^,10就是整体的第15小
//      arr2中并不是所有数字都有可能,1^最好情况干过10,也到不了第15小,也就是第十一小,即1^~4^ 全部都不可能,4^最好情况把第10干过了,也就是第14小
//      看arr2的后面,16^和17^都不可能，16^在自己的数组中已经有16了,怎么可能是第15小呢? 17^同理
//      这样一来长数组可能的范围5^~15^
//  但是现在无法调用f函数,因为arr1中是10个数字,而5^~15^是11个数,哇哦 恶心！
//  手动判断5^是不是第15小,如果5^>=10,5^就是第15小,直接返回。如果5^不是第15小,多淘汰掉了一个,这样一来，我就是10个数对10个数了
//  总结：现在已经淘汰掉了1^~5^一共五个数字,对于f函数调用的过程当中是,arr1中的十个数字,arr2中十个数字取整体上中位数,跟前面淘汰掉的5个一凑,正好是第15小.
//  不能扣掉15^的而是扣掉5^的原因？我们当然可以手动判断扣掉15^,只要他比1小即可(15^就是答案),但是如果把15^扣掉,但是如果拿5^~14^这一段去跟arr1求上中位数,就不对了
//  因为左侧淘汰掉的数字是4个,接下来拿10个数与10个数求整体的上中位数,一凑,只凑到第14小,所以扣左别扣右.
//3)17(长数组长度)<k<=27(两数组之和),比如求第13小
//      arr1: 1 2 3 4 5 6 7 8 9 10
//      arr2: 1^2^3^4^5^6^7^8^9^10^11^12^13^14^15^16^17^
//      arr1中1~5都不可能,5最好情况干过了17^,也不过是第22小,可能范围是6~10
//      arr2中12^之前都不可能,12^最好情况干过10,也不过是第22小
//      所以可能的情况就是 arr1中 6~10 arr2中13^~17^,而且是等长的,我也是五个数,你也是五个数
//  但是不可以直接调用f函数 02:03
public class Problem_0004_MedianOfTwoSortedArrays {
    //暂时省略
}
